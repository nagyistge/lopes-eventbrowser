#include "CanvasCollection.h"
#include "global.h"

//the line that identifies a file as a valid canvas config file
#define MAGIC_LINE ";-*-EVENT_BROWSER_CANVASES-*-"

#ifdef DEBUG
#include <iostream>

#endif

using namespace std;

CanvasCollection::CanvasCollection() {};

CanvasCollection::~CanvasCollection()
{
	for (int i = 0; i < (int) canvases.size(); ++i)
	{
	    delete canvases[i];
	}
}

void CanvasCollection::removeCanvas(int index)
{
	delete canvases[index];
	canvases.erase(canvases.begin() + index);
}

// CanvasCollection* CanvasCollection::clone()
// {
// 	CanvasCollection *c = new CanvasCollection();
// 	c->canvases.resize(canvases.size());
// 	for (int i = 0; i < (int) canvases.size(); ++i)
// 	{
// 	    c->canvases[i] = canvases[i];
// 	}
// 	return c;
// }

void CanvasCollection::print()
{
	cout << "-----------------------------------" << endl;
	for (int i = 0; i <(int) canvases.size(); ++i)
	{
	
		cout << canvases[i]->getName() << endl;
	}
		
}

void CanvasCollection::saveToFile(string filename)
{
 	ofstream file;
 	file.open (filename.c_str(), ios::trunc);
 	if (file.is_open())
 	{
		file << MAGIC_LINE << endl;
		file << 
";************************************************ \n"
";This file is generated by browser and contains \n"
";definitions of canvases created during a program\n"
";session. This file can be parsed later by the\n"
";program.\n"
";\n"
";You can edit this file by hand; in which case, be\n"
";aware of the syntax:\n"
";each \"canvas\" is headed by a header of the format:\n"
";[Canvas:_canvas type_]\n"
";where canvas type corresponds to the enum defined\n"
";in Canvas.h. The rest of the variables are defined\n"
";in the format:\n"
";name = value\n"
";\"name\" conforms to the rules regarding the names\n"
";of c-style variables.\n"
";************************************************     \n"
			 << endl;
		
 		for (int i = 0; i < (int) canvases.size(); ++i)
			canvases[i]->streamToFile(file);

 		file.close();
 	}
}

CanvasCollection* CanvasCollection::readFromFile()
{
// 	ifstream f(COLUMN_FILE);

// 	string shown,exp,alias;

// 	CanvasCollection* cc = new CanvasCollection;
// 	Canvas *c;

// 	while (!getline(f,shown,CFG_SEPARATOR).eof())
// 	{
// 		getline(f,exp,CFG_SEPARATOR);
// 		getline(f,alias);

// 		c = new Canvas((shown == "1")? true : false, exp, alias);
// 		cc->addCanvas(c);
// 	}

// 	return cc;
}
